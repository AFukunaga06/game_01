<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Dot Avoid Run â€” Minimal</title>
  <style>
    :root { --bg: #0f1220; --ui: #ffffff; --accent: #71e6ff; --danger:#ff5d78; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--ui); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif; }
    #wrap { position: relative; width: min(420px, 100vw); margin: 0 auto; }
    canvas { width: 100%; height: auto; display: block; background: linear-gradient(180deg, #0b0f1a 0%, #0f1220 100%); border: 1px solid rgba(255,255,255,.08); border-radius: 16px; }
    .hud { position:absolute; inset:0; pointer-events:none; }
    .score { position:absolute; top:8px; left:12px; font-weight:700; letter-spacing:.5px; text-shadow:0 2px 6px rgba(0,0,0,.6); }
    .best { position:absolute; top:8px; right:12px; opacity:.85; }
    .btnbar { position:absolute; bottom:10px; left:0; right:0; display:flex; justify-content:center; gap:10px; pointer-events:auto; }
    .btn { padding:10px 14px; border-radius:12px; border:1px solid rgba(255,255,255,.15); background: rgba(255,255,255,.06); color:#fff; font-weight:700; cursor:pointer; backdrop-filter: blur(4px); }
    .btn:active { transform: translateY(1px); }
    #overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background: rgba(0,0,0,.55); pointer-events:auto; }
    .card { width:min(85%, 360px); background: rgba(17,20,36,.95); border:1px solid rgba(255,255,255,.12); border-radius:16px; padding:18px; text-align:center; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    .title { font-size:22px; font-weight:800; margin:2px 0 8px; }
    .muted { opacity:.85; font-size:14px; }
    .actions { display:flex; gap:8px; justify-content:center; margin-top:12px; }
    .adchip { display:inline-block; padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.08); border:1px dashed rgba(255,255,255,.25); font-size:12px; margin-top:6px; }
    .hide { display:none !important; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="360" height="640" aria-label="Dot Avoid Run"></canvas>
    <div class="hud">
      <div class="score" id="score">0 m</div>
      <div class="best" id="best">Best: 0 m</div>
      <div class="btnbar">
        <button class="btn" id="btnPause">â¸ ä¸€æ™‚åœæ­¢</button>
        <button class="btn" id="btnRestart">ğŸ” ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button>
      </div>
    </div>
    <!-- Overlay (menu / gameover / fake ad) -->
    <div id="overlay" class="hide">
      <div class="card" id="menuCard">
        <div class="title">Dot Avoid Run</div>
        <div class="muted">1æœ¬æŒ‡ã§å·¦å³ã«å‹•ã‹ã—ã¦ã€éšœå®³ç‰©ã®ã™ãé–“ã‚’æŠœã‘ã‚ˆã†ï¼</div>
        <div class="actions">
          <button class="btn" id="btnStart">â–¶ ã¯ã˜ã‚ã‚‹</button>
        </div>
        <div style="margin-top:8px; font-size:12px; opacity:.85;">PC: â† â†’ / A D ã‚­ãƒ¼ã§ã‚‚ç§»å‹•</div>
      </div>
      <div class="card hide" id="overCard">
        <div class="title" id="overTitle">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</div>
        <div class="muted">ã‚¹ã‚³ã‚¢: <b id="finalScore">0</b> m</div>
        <div class="adchip">åºƒå‘Šãƒ‡ãƒ¢: å ±é…¬å‹ã§å¾©æ´»ã§ãã¾ã™</div>
        <div class="actions">
          <button class="btn" id="btnRevive">ğŸ¥ åºƒå‘Šã‚’è¦‹ã¦å¾©æ´»ï¼ˆãƒ‡ãƒ¢ï¼‰</button>
          <button class="btn" id="btnAgain">ğŸ” ã‚‚ã†ä¸€åº¦</button>
        </div>
      </div>
      <div class="card hide" id="adCard">
        <div class="title">åºƒå‘Šè¦–è´ä¸­â€¦ï¼ˆãƒ‡ãƒ¢ï¼‰</div>
        <div class="muted">ã‚ã¨ <b id="adCountdown">3</b> ç§’</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ================== åŸºæœ¬è¨­å®š ==================
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // ç«¯æœ«ã®è§£åƒåº¦ã«åˆã‚ã›ã¦ãƒ‰ãƒƒãƒˆã‚’é«˜ç²¾ç´°åŒ–
  const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  function resizeCanvas() {
    const { width, height } = canvas;
    canvas.width = Math.floor(width * dpr);
    canvas.height = Math.floor(height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // è«–ç†ã‚µã‚¤ã‚º=CSSãƒ”ã‚¯ã‚»ãƒ«
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // ================== ã‚²ãƒ¼ãƒ ã‚¹ãƒ†ãƒ¼ãƒˆ ==================
  const STATE = { MENU: 'menu', PLAY: 'play', PAUSE:'pause', OVER:'over', AD:'ad' };
  let state = STATE.MENU;
  let revivedOnce = false;

  // ã‚¹ã‚³ã‚¢
  let distance = 0; // m è¡¨ç¤º
  let best = Number(localStorage.getItem('dar_best') || 0);
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  bestEl.textContent = `Best: ${best} m`;

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
  const player = {
    x: canvas.width / dpr / 2 - 12,
    y: canvas.height / dpr - 120,
    w: 24,
    h: 24,
    speedX: 0,
    maxSpeed: 260, // px/sec
    invulTime: 0,
  };

  // å…¥åŠ›
  let inputX = null; // ç›®æ¨™åº§æ¨™ï¼ˆã‚¿ãƒƒãƒ/ãƒã‚¦ã‚¹ï¼‰
  let keyL = false, keyR = false;

  // éšœå®³ç‰©ï¼ˆä¸Šä¸‹ã«å¸¯ + ã™ãé–“ï¼‰
  const obstacles = [];
  let spawnTimer = 0;
  let gameTime = 0; // ç´¯è¨ˆçµŒé

  const params = {
    baseScroll: 120,    // px/secï¼ˆéšœå®³ç‰©ã®è½ä¸‹é€Ÿåº¦ï¼‰
    spawnInterval: 0.9, // ç§’
    thickness: 22,      // å¸¯ã®åšã¿
    gapMin: 90,
    gapMax: 180,
  };

  function resetGame(full=true) {
    distance = 0;
    gameTime = 0;
    spawnTimer = 0;
    obstacles.length = 0;
    player.x = canvas.width / dpr / 2 - player.w/2;
    player.speedX = 0;
    player.invulTime = 0;
    if (full) revivedOnce = false;
  }

  // ================== ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ ==================
  function rand(min, max){ return Math.random() * (max - min) + min; }

  function difficultyCurve(t){
    // t(ç§’)ã«å¿œã˜ã¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é€Ÿåº¦â†‘ / ã™ãé–“â†“ / å‡ºç¾é–“éš”â†“
    const scroll = params.baseScroll + Math.min(260, t*10); // å¾ã€…ã«æ—©ã
    const gap = Math.max(params.gapMin, params.gapMax - t*1.5); // ã ã‚“ã ã‚“ç‹­ã
    const interval = Math.max(0.45, params.spawnInterval - t*0.004); // ã ã‚“ã ã‚“é »ç¹
    return { scroll, gap, interval };
  }

  function spawnObstacle() {
    const { gap } = difficultyCurve(gameTime);
    const W = canvas.width / dpr;
    const gapW = gap;
    const gapX = Math.max(16, Math.min(W - gapW - 16, rand(0, W - gapW))); // ç«¯ã¯å°‘ã—ä½™ç™½
    const y = -params.thickness - 4;
    obstacles.push({ y, gapX, gapW, hit:false });
  }

  // ================== è¡çªåˆ¤å®šï¼ˆå¸¯ã®å·¦å³ãƒ–ãƒ­ãƒƒã‚¯ã¨AABBï¼‰ ==================
  function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function checkCollision(o){
    const W = canvas.width / dpr;
    const y = o.y;
    const th = params.thickness;

    // å·¦ãƒ–ãƒ­ãƒƒã‚¯
    const L = { x: 0, y, w: o.gapX, h: th };
    // å³ãƒ–ãƒ­ãƒƒã‚¯
    const R = { x: o.gapX + o.gapW, y, w: Math.max(0, W - (o.gapX + o.gapW)), h: th };

    const p = player;
    return rectsOverlap(p.x, p.y, p.w, p.h, L.x, L.y, L.w, L.h) ||
           rectsOverlap(p.x, p.y, p.w, p.h, R.x, R.y, R.w, R.h);
  }

  // ================== ãƒ«ãƒ¼ãƒ— ==================
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last) / 1000); // å®‰å®šåŒ–ï¼ˆæœ€å¤§33msï¼‰
    last = now;

    if (state === STATE.PLAY) update(dt);
    render();
    requestAnimationFrame(loop);
  }

  function update(dt){
    gameTime += dt;
    const { scroll, gap, interval } = difficultyCurve(gameTime);

    // å…¥åŠ›â†’æ¨ªç§»å‹•
    const W = canvas.width / dpr;
    if (inputX !== null){
      const target = Math.max(0, Math.min(W - player.w, inputX - player.w/2));
      const dir = Math.sign(target - player.x);
      player.speedX = dir * player.maxSpeed;
      if (Math.abs(target - player.x) < 4) player.speedX = 0;
    } else {
      // ã‚­ãƒ¼æ“ä½œ
      const dir = (keyR?1:0) - (keyL?1:0);
      player.speedX = dir * player.maxSpeed;
    }
    player.x += player.speedX * dt;
    player.x = Math.max(0, Math.min(W - player.w, player.x));

    // éšœå®³ç‰©ã®ç§»å‹• & ç”Ÿæˆ
    for (const o of obstacles){ o.y += scroll * dt; }
    spawnTimer += dt;
    if (spawnTimer >= interval){ spawnTimer = 0; spawnObstacle(); }

    // ç”»é¢å¤–ã®é™¤å»
    for (let i=obstacles.length-1; i>=0; i--){
      if (obstacles[i].y > canvas.height/dpr + 40) obstacles.splice(i,1);
    }

    // ã‚¹ã‚³ã‚¢
    distance = Math.max(0, Math.floor(gameTime * (scroll/6)));
    scoreEl.textContent = distance + ' m';

    // ç„¡æ•µã‚¿ã‚¤ãƒ æ¸›è¡°
    if (player.invulTime > 0) player.invulTime -= dt;

    // å½“ãŸã‚Šåˆ¤å®š
    if (player.invulTime <= 0){
      for (const o of obstacles){
        if (checkCollision(o)) { onGameOver(); break; }
      }
    }
  }

  function render(){
    const W = canvas.width / dpr; const H = canvas.height / dpr;
    // èƒŒæ™¯ï¼ˆç°¡æ˜“ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ + ãƒ©ã‚¤ãƒ³ï¼‰
    ctx.clearRect(0,0,W,H);
    // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒ©ã‚¤ãƒ³
    ctx.globalAlpha = 0.07;
    ctx.fillStyle = '#ffffff';
    for (let y= (-(performance.now()/20)%40); y < H; y+=40){
      ctx.fillRect(0, y, W, 2);
    }
    ctx.globalAlpha = 1;

    // éšœå®³ç‰©
    for (const o of obstacles){
      ctx.fillStyle = '#18223e';
      ctx.fillRect(0, o.y, o.gapX, params.thickness); // å·¦
      const rightX = o.gapX + o.gapW;
      ctx.fillRect(rightX, o.y, Math.max(0, W - rightX), params.thickness); // å³
      // è¼ªéƒ­
      ctx.globalAlpha = .25; ctx.fillStyle = '#71e6ff';
      ctx.fillRect(0, o.y, o.gapX, 1);
      ctx.fillRect(rightX, o.y, Math.max(0, W - rightX), 1);
      ctx.globalAlpha = 1;
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
    const blink = (player.invulTime>0 && Math.floor(player.invulTime*20)%2===0);
    if (!blink){
      ctx.fillStyle = '#71e6ff';
      const r = 6; // è§’ä¸¸
      roundRect(ctx, player.x, player.y, player.w, player.h, r);
      ctx.fill();
    }
  }

  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  // ================== UI / é€²è¡Œç®¡ç† ==================
  const overlay = document.getElementById('overlay');
  const menuCard = document.getElementById('menuCard');
  const overCard = document.getElementById('overCard');
  const adCard = document.getElementById('adCard');
  const btnStart = document.getElementById('btnStart');
  const btnAgain = document.getElementById('btnAgain');
  const btnRevive = document.getElementById('btnRevive');
  const btnPause = document.getElementById('btnPause');
  const btnRestart = document.getElementById('btnRestart');
  const finalScore = document.getElementById('finalScore');
  const overTitle = document.getElementById('overTitle');
  const adCountdown = document.getElementById('adCountdown');

  function showOverlay(which){
    overlay.classList.remove('hide');
    menuCard.classList.add('hide');
    overCard.classList.add('hide');
    adCard.classList.add('hide');
    if (which==='menu') menuCard.classList.remove('hide');
    if (which==='over') overCard.classList.remove('hide');
    if (which==='ad') adCard.classList.remove('hide');
  }
  function hideOverlay(){ overlay.classList.add('hide'); }

  function startGame(){
    resetGame(true);
    state = STATE.PLAY;
    hideOverlay();
    logEvent('game_start');
  }

  function onGameOver(){
    state = STATE.OVER;
    finalScore.textContent = distance;
    if (distance > best){ best = distance; localStorage.setItem('dar_best', best); }
    bestEl.textContent = `Best: ${best} m`;
    overTitle.textContent = revivedOnce ? 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼' : 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼ˆå¾©æ´»å¯ï¼‰';
    showOverlay('over');
    logEvent('game_over', { score: distance });
  }

  function reviveFlow(){
    if (revivedOnce) return; // ä¸€åº¦ã ã‘
    revivedOnce = true;
    // åºƒå‘Šãƒ‡ãƒ¢
    showOverlay('ad');
    state = STATE.AD;
    let t = 3;
    adCountdown.textContent = t;
    const timer = setInterval(()=>{
      t--; adCountdown.textContent = t;
      if (t<=0){
        clearInterval(timer);
        // å¾©æ´»
        player.invulTime = 2.5; // ç„¡æ•µ
        // ç›´è¿‘ã®éšœå®³ç‰©ã‚’å°‘ã—ä¸‹ã¸å‹•ã‹ã—å®‰å…¨ã«
        for (const o of obstacles){ o.y += 60; }
        hideOverlay();
        state = STATE.PLAY;
        logEvent('revive');
      }
    }, 1000);
  }

  btnStart.addEventListener('click', startGame);
  btnAgain.addEventListener('click', () => { startGame(); });
  btnRevive.addEventListener('click', () => { if (!revivedOnce) reviveFlow(); });
  btnPause.addEventListener('click', () => {
    if (state === STATE.PLAY){ state = STATE.PAUSE; btnPause.textContent = 'â–¶ å†é–‹'; }
    else if (state === STATE.PAUSE){ state = STATE.PLAY; btnPause.textContent = 'â¸ ä¸€æ™‚åœæ­¢'; }
  });
  btnRestart.addEventListener('click', () => { startGame(); });

  // åˆæœŸã¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¡¨ç¤º
  showOverlay('menu');

  // å…¥åŠ›ï¼ˆã‚¿ãƒƒãƒ/ãƒã‚¦ã‚¹ï¼‰
  const wrap = document.getElementById('wrap');
  function clientX(e){ return (e.touches? e.touches[0].clientX : e.clientX); }
  function onPointerDown(e){ if (state===STATE.MENU) return; inputX = getLocalX(clientX(e)); }
  function onPointerMove(e){ if (inputX!==null) inputX = getLocalX(clientX(e)); }
  function onPointerUp(){ inputX = null; }
  function getLocalX(client){
    const rect = canvas.getBoundingClientRect();
    const x = (client - rect.left) * (canvas.width/dpr) / rect.width; // CSSâ†’è«–ç†åº§æ¨™
    return x;
  }

  wrap.addEventListener('mousedown', onPointerDown);
  wrap.addEventListener('mousemove', onPointerMove);
  window.addEventListener('mouseup', onPointerUp);
  wrap.addEventListener('touchstart', (e)=>{ e.preventDefault(); onPointerDown(e); }, {passive:false});
  wrap.addEventListener('touchmove', (e)=>{ e.preventDefault(); onPointerMove(e); }, {passive:false});
  wrap.addEventListener('touchend', (e)=>{ e.preventDefault(); onPointerUp(e); }, {passive:false});

  // ã‚­ãƒ¼
  window.addEventListener('keydown', (e)=>{ if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') keyL=true; if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') keyR=true; });
  window.addEventListener('keyup',   (e)=>{ if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') keyL=false; if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') keyR=false; });

  // ç°¡æ˜“ã‚¢ãƒŠãƒªãƒ†ã‚£ã‚¯ã‚¹ï¼ˆã‚ã¨ã§SDKã«å·®ã—æ›¿ãˆå¯èƒ½ï¼‰
  function logEvent(name, payload={}){ try{ console.log('[analytics]', name, payload); }catch(_){} }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
